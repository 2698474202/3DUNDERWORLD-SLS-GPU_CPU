/*
 * Dynamic_Bitset on GPU
 */
#pragma once
#include "CUDA_Error.cuh"
#include <vector>
#include <cuda_runtime.h>
#include <cuda.h>


namespace SLS
{


/**
 * @brief A dynamic bitset array in GPU
 * This struct contains all required information of a dynamic array with `numElem` elements 
 * and each element contains `bitsPerElem` bits, 
 * as well as necessary **device** functions to manipulate bits in kernels.
 * Also there are two functions can be called in **host** code to query `numElem` and `bitsPerElem`.
 *
 * *Please note that this struct can only be generated by `GetGPUOBJ` function in a 
 * `Dynamic_Bitset_Array` object. `*bits` is a pointer to a GPU memory*
 */
struct Dynamic_Bitset_Array_GPU
{
    unsigned char* bits;
    size_t BITS_PER_BYTE;
    size_t numElem;
    size_t bitsPerElem;
    /* Set or clear a bit in uchar
     * position should be within BIT_PER_BYTE
     * http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
     */

    /**
     * @brief Set bit of a char to 1
     *
     * @param ch Char to operate
     * @param pos Position within the char
     */
    __device__ void setUChar(unsigned char& ch, const size_t &pos) { 
        ch |= 1<<pos; 
        //atomicOr( ch , 1<<pos);
    }
    /**
     * @brief Set bit of a char to 0
     *
     * @param ch Char to operate
     * @param pos Position within the char
     */
    __device__ void clearUChar(unsigned char& ch, const size_t &pos) { 
        ch &= ~(1<<pos);
        //atomicAnd(ch, ~(1<<pos));
    }

    /**
     * @brief Get bit of within a char
     *
     * @param ch Char to query
     * @param pos position of bit in char
     *
     * @return Ture if 1; otherwise, 0.
     */
    __device__ bool getUChar(const unsigned char& ch, const size_t &pos)const {return (ch>>pos)&1;}
    __device__ void setBit(const size_t &pos, const size_t &elem)
    {
        unsigned char *e = &bits[(elem * bitsPerElem)/BITS_PER_BYTE];
        setUChar( e[pos/BITS_PER_BYTE], pos%BITS_PER_BYTE);
    }
    __device__ void clearBit(const size_t &pos, const size_t &elem)
    {
        unsigned char *e = &bits[(elem * bitsPerElem)/BITS_PER_BYTE];
        clearUChar( e[pos/BITS_PER_BYTE], pos%BITS_PER_BYTE);
    }
    __device__ bool getBit(const size_t &pos, const size_t &elem) const
    {
        unsigned char *e = &bits[(elem * bitsPerElem)/BITS_PER_BYTE];
        return getUChar( e[pos/BITS_PER_BYTE], pos%BITS_PER_BYTE);
    }
    __device__ __host__ size_t getNumElem() const { return numElem;}
    __device__ __host__ size_t getBitsPerElem() const { return bitsPerElem;}

    __device__ unsigned int to_uint(const size_t &elem) const
    {
        if (bitsPerElem > sizeof(uint)*BITS_PER_BYTE)   // Break if longer than uint
        {
            __threadfence();
            asm("trap;");
        }
        unsigned char *e = &bits[(elem * bitsPerElem)/BITS_PER_BYTE];
        unsigned int res = 0;
        for (size_t i=0; i<bitsPerElem/BITS_PER_BYTE; i++)
            res+= ( (unsigned int)e[i]<<(i*BITS_PER_BYTE));
        return res;
    }

    // Hack to swap lower 10 bits with heigher 10 bits
    __device__ unsigned to_uint_gray(const size_t &elem, unsigned numLowerBits, unsigned numHigherBits) const
    {
        if (bitsPerElem > sizeof(uint)*BITS_PER_BYTE)   // Break if longer than uint
        {
            __threadfence();
            asm("trap;");
        }
        //Lower
        unsigned lower = 0;

        bool lowestBit = getBit(0, elem);
        if(lowestBit)
            lower += 1<<(numLowerBits-1);
        for (unsigned i=1; i<numLowerBits; i++)
        {
            lowestBit = getBit(i, elem) != lowestBit;
            if (lowestBit)
                lower += (unsigned)1<<(numLowerBits-i-1);
        }

    
        //for (unsigned i=0; i<numLowerBits; i++)
        //    lower += getBit(i, elem)?1<<(numLowerBits-1-i):0;
        //if (numLowerBits < 32)
        //{
        //    lower = lower ^ (lower>>16);
        //    lower = lower ^ (lower>>8);
        //    lower = lower ^ (lower>>4);
        //    lower = lower ^ (lower>>2);
        //    lower = lower ^ (lower>>1);
        //}

        //Higher
        unsigned heigher = 0;
        lowestBit = getBit(numLowerBits, elem);
        if (lowestBit)
            heigher += 1<<(numHigherBits-1);
        for (unsigned i=1; i<numHigherBits; i++)
        {
            lowestBit = getBit(i+numLowerBits, elem) != lowestBit;
            if (lowestBit)
                heigher += 1<<(numHigherBits-i-1);
        }
        //for (unsigned i=0; i< numHigherBits; i++)
        //    heigher += getBit(i+numLowerBits, elem)?1<<(numHigherBits-i-1):0;
        //if (numHigherBits < 32)
        //{
        //    heigher = heigher ^ (lower>>16);
        //    heigher = heigher ^ (lower>>8);
        //    heigher = heigher ^ (lower>>4);
        //    heigher = heigher ^ (lower>>2);
        //    heigher = heigher ^ (lower>>1);
        //}

        if (lower >= 768 || heigher >= 1024)
        {
            return 1024*768+1;
        }

        return lower*1024+heigher;
    }
};

class Dynamic_Bitset_Array{
private:
    unsigned char* bits;
    const size_t BITS_PER_BYTE;
    const size_t numElem;
    const size_t bitsPerElem;
public:
    Dynamic_Bitset_Array(size_t numberElements, size_t bitsPerElement): 
        BITS_PER_BYTE(8), 
        numElem(numberElements), 
        bitsPerElem(ceil((float)bitsPerElement/(float)BITS_PER_BYTE)*BITS_PER_BYTE)// Making sure integer nubmer of bytes
    {
        const size_t numBytes = (numElem * bitsPerElem + BITS_PER_BYTE -1)/BITS_PER_BYTE;
        gpuErrchk(cudaMalloc ((void**)&bits, numBytes));
        gpuErrchk(cudaMemset (bits, 0, numBytes));
    }
    ~Dynamic_Bitset_Array()
    {
        gpuErrchk( cudaFree(bits));
    }
    Dynamic_Bitset_Array_GPU getGPUOBJ() const  //Get an GPU object to process
    {
        Dynamic_Bitset_Array_GPU obj{bits, BITS_PER_BYTE, numElem, bitsPerElem};
        return obj;
    }

    /**
     * @brief Write an element to PGM file
     *
     * @param fileName
     * @param elemIdx
     * @param w
     * @param h
     * @param transpose False if data is row based, otherwise, column based.
     *
     * @return true if writen
     */
    bool writeElemToPGM( std::string fileName, size_t elemIdx ,const size_t &w, const size_t &h, bool transpose=false);

    /**
     * @brief Write it to gray scale image
     *
     * @param fileName
     * @param w
     * @param h
     * @param transpose
     * @param maxValue Maximum value, if not set, is defined by number of bits
     *
     * @return true if success.
     */
    bool writeToPGM( std::string fileName, size_t w, size_t h, bool transposed=false, unsigned int maxValue=0);

    /**
     * @brief Write it to color ppm images
     *
     * @param fileName
     * @param w
     * @param h
     * @param transpose
     * @param maxValue Maximum value, if not set, is defined by number of bits
     *
     * @return true if success.
     */
    bool writeToPPM( std::string fileName, size_t w, size_t h, bool transposed=false, unsigned int maxValue=0);

};

// ==== Kernels == 
namespace Kernel
{
__global__ void toUintArray(
        Dynamic_Bitset_Array_GPU bitsArray,
        unsigned int *uintArray
        );

/**
 * @brief Convert binary array to normalized uint array.
 *
 * @param bitsArray input bit array
 * @param capValue  The value that normalized to
 * @param maxValue  The maximum value that exist in the array
 * @param *uintArray output Array
 *
 * @return 
 */
__global__ void toNormalizedUintArray(
        Dynamic_Bitset_Array_GPU bitsArray,
        unsigned int capValue,
        unsigned int maxValue,
        unsigned int *uintArray
        );
}// namespace Kernel
}
